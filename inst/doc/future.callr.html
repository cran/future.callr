<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>A Future for callr</title>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.6.0/build/styles/github.min.css">
<script src="https://cdn.jsdelivr.net/combine/gh/highlightjs/cdn-release@11.6.0/build/highlight.min.js,npm/@xiee/utils/js/load-highlight.js" async></script>



<style type="text/css">
body, td {
  font-family: sans-serif;
  background-color: white;
  font-size: 13px;
}
body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
}
tt, code, pre {
  font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}
a:visited { color: #80007f; }
pre, img { max-width: 100%; }
code {
  font-size: 92%;
  border: 1px solid #ccc;
}
code[class] { background-color: #F8F8F8; }
code.language-undefined { background-color: inherit; }
table {
  margin: auto;
  border-top: 1px solid #666;
  border-bottom: 1px solid #666;
}
table thead th { border-bottom: 1px solid #ddd; }
th, td { padding: 5px; }
thead, tfoot, tr:nth-child(even) { background: #eee; }
blockquote {
  color:#666;
  margin:0;
  padding-left: 1em;
  border-left: 0.5em #eee solid;
}
hr { border: 1px #ddd dashed; }

@media print {
  * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
  }
  body {
    font-size: 12pt;
    max-width: 100%;
  }
  a, a:visited { text-decoration: underline; }
  hr {
    visibility: hidden;
    page-break-before: always;
  }
  pre, blockquote {
    padding-right: 1em;
    page-break-inside: avoid;
  }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page :left { margin: 15mm 20mm 15mm 10mm; }
  @page :right { margin: 15mm 10mm 15mm 20mm; }
  p, h2, h3 { orphans: 3; widows: 3; }
  h2, h3 { page-break-after: avoid; }
}
</style>

<meta name="keywords" content="R, package, vignette, future, synchronous, asynchronous, parallel, cluster, HPC, callr">
<meta name="author" content="Henrik Bengtsson">

</head>

<body>
<h1>A Future for callr</h1>
<h2>Introduction</h2>
<p>The <strong><a href="https://cran.r-project.org/package=future">future</a></strong> package provides a generic API for using futures in
R.  A future is a simple yet powerful mechanism to evaluate an R
expression and retrieve its value at some point in time.  Futures can
be resolved in many different ways depending on which strategy is
used.  There are various types of synchronous and asynchronous futures
to choose from in the <strong><a href="https://cran.r-project.org/package=future">future</a></strong> package.</p>
<p>This package, <strong><a href="https://cran.r-project.org/package=future.callr">future.callr</a></strong>, provides a type of futures that
utilizes the <strong><a href="https://cran.r-project.org/package=callr">callr</a></strong> package.</p>
<p>For example,</p>
<pre><code class="language-r">&gt; library(&quot;future.callr&quot;)
&gt; plan(callr)
&gt;
&gt; x %&lt;-% { Sys.sleep(5); 3.14 }
&gt; y %&lt;-% { Sys.sleep(5); 2.71 }
&gt; x + y
[1] 5.85
</code></pre>
<p>This is obviously a toy example to illustrate what futures look like
and how to work with them.  For further examples on how to use
futures, see the vignettes of the <strong><a href="https://cran.r-project.org/package=future">future</a></strong> package as well as
those of <strong><a href="https://cran.r-project.org/package=future.apply">future.apply</a></strong> and <strong><a href="https://cran.r-project.org/package=doFuture">doFuture</a></strong>.</p>
<h2>Using the callr backend</h2>
<p>The <strong>future.callr</strong> package implements a <strong>future</strong> backend wrapper
for <strong>callr</strong>.</p>
<table>
<thead>
<tr>
<th align="left">Backend</th>
<th align="left">Description</th>
<th align="left">Alternative in future package</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>callr</code></td>
<td align="left">parallel evaluation in a separate R process (on current machine)</td>
<td align="left"><code>plan(multisession)</code></td>
</tr>
</tbody>
</table>
<h3>Each callr future uses a fresh R session</h3>
<p>When using <code>callr</code> futures, each future is resolved in a fresh
background R session which ends as soon as the value of the future has
been collected.  In contrast, <code>multisession</code> futures are resolved in
background R worker sessions that serve multiple futures over their
life spans.  The advantage with using a new R process for each future
is that it is that the R environment is guaranteed not to be
contaminated by previous futures, e.g. memory allocations, finalizers,
modified options, and loaded and attached packages.  The disadvantage,
is an added overhead of launching a new R process.  (At the moment, I
am neither aware of formal benchmarking of this extra overhead nor of
performance comparisons of <code>callr</code> to alternative future backends.)</p>
<h3>More than 125 parallel callr futures</h3>
<p>Another advantage with <code>callr</code> futures compared to <code>multisession</code>
futures is that they do not communicate via R (socket) connections.
This avoids the limitation in the number of parallel futures that can
be active at any time that <code>multisession</code> futures and <code>cluster</code>
futures in general have, which they inherit from <code>SOCKcluster</code>
clusters as defined by the <strong>parallel</strong> package.  The number of
parallel futures these can serve is limited by the <a href="https://github.com/HenrikBengtsson/Wishlist-for-R/issues/28">maximum number of
open connections in
R</a>, which
currently is 125 (excluding the three reserved by R itself).  Note
that these 125 slots have to be shared with file connections etc.  To
increase this limit, R has to be rebuilt from source.  However, since
<code>callr</code> futures rely on <a href="https://github.com/r-lib/processx/issues/91">the callr package which does not make use of
R-specific connections</a>,
there is no limit in the number of background R processes that can be
used simultaneously.</p>
<h3>No ports are used - no port clashes or firewall issues</h3>
<p>A third advantage with <code>callr</code> futures, is that there is not risk for
port-clashing with other processes on the system when clusters are set
up (*), because <strong>callr</strong> does not rely on ports.  Furthermore, on
Windows, the firewall triggers an alert that the user needs to approve
whenever a not-previously-approved port is requested by R - <a href="https://stackoverflow.com/questions/47353848/localhost-connection-without-firewall-popup/47542866">which
happens also for local, non-public
ports</a>
that are used by <code>SOCKcluster</code>:s.  When using <code>callr</code> futures, no
sockets and therefore no ports are involved.</p>
<p>(*) To lower the risk for such clashes <code>SOCKcluster</code>:s (of the
<strong>parallel</strong> package) request random ports, but clashes still occur at
times.</p>
<h2>Demos</h2>
<p>The <strong><a href="https://cran.r-project.org/package=future">future</a></strong> package provides a demo using futures for calculating
a set of Mandelbrot planes.  The demo does not assume anything about
what type of futures are used.  <em>The user has full control of how
futures are evaluated</em>.  For instance, to use <code>callr</code> futures, run the
demo as:</p>
<pre><code class="language-r">library(&quot;future.callr&quot;)
plan(callr)
demo(&quot;mandelbrot&quot;, package = &quot;future&quot;, ask = FALSE)
</code></pre>


<script src="https://cdn.jsdelivr.net/combine/npm/@xiee/utils/js/center-img.min.js" async></script>
</body>

</html>
